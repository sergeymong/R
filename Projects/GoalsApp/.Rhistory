need3
}
diff_between_df(avian, avian2, type = "Ht", m = "max")
diff_between_df <- function(df1, df2, type = "P", m = "max"){
cols <- names(df1)[grepl(type, names(df1))]
need1 <- apply(df1[, cols], 2, m)
need1 <- sort(need1, decreasing = T)
need2 <- apply(df2[, cols], 2, m)
need2 <- sort(need2, decreasing = T)
need3 <- round(abs(need1 - need2), digits = 4)
print(paste(m,"different between", name(df1), name(df2), "for", type, "is"))
need3
}
diff_between_df(avian, avian2, type = "Ht", m = "max")
diff_between_df <- function(df1, df2, type = "P", m = "max"){
cols <- names(df1)[grepl(type, names(df1))]
need1 <- apply(df1[, cols], 2, m)
need1 <- sort(need1, decreasing = T)
need2 <- apply(df2[, cols], 2, m)
need2 <- sort(need2, decreasing = T)
need3 <- round(abs(need1 - need2), digits = 4)
print(paste(m,"different", "for", type, "is"))
need3
}
diff_between_df(avian, avian2, type = "Ht", m = "max")
rm(list = ls())
paste(c("углекислый", "веселящий"), "газ")
paste(c("углекислый", "веселящий"), "газ")
options(encoding="UTF-8")
paste(c("углекислый", "веселящий"), "газ")
options(encoding="KOI8-R")
paste(c("углекислый", "веселящий"), "газ")
Sys.setlocale(locale = "Russian")
Sys.setlocale("LC_CTYPE", "russian")
Sys.setlocale("LC_CTYPE", "Russian")
Sys.setlocale("LC_CTYPE", "en_RU.UTF-8")
Sys.setlocale("LC_CTYPE", "en_RU.UTF-8")
Sys.setlocale(locale = "Russian")
paste(c("углекислый", "веселящий"), "газ")
encoding(paste(c("углекислый", "веселящий"), "газ"))
Encoding(paste(c("углекислый", "веселящий"), "газ"))
Sys.getlocale()
Sys.getlocale()
Sys.setlocale(locale = "Russian")
Encoding(paste(c("углекислый", "веселящий"), "газ"))
paste(c("углекислый", "веселящий"), "газ")
paste0(c("углекислый", "веселящий"), "газ")
Sys.getlocale()
paste0(c("углекислый", "веселящий"), "газ")
paste0(c("углекислый ", "веселящий "), "газ")
paste(c("углекислый", "веселящий"), "газ")
paste(c("углекислый", "веселящий"), "газ", sep = "_")
paste(c("углекислый", "веселящий"), "газ", sep = "_", collapse = "а также")
paste(c("углекислый", "веселящий"), "газ", sep = "_", collapse = ", а также")
paste(c("углекислый", "веселящий"), "газ", sep = "_", collapse = ", а также ")
s <- c("Без труда не вытащишь и рыбку из пруда",
"Терпение и труд всё перетрут",
"Кончил дело -- гуляй смело",
"Работа не волк, в лес не убежит")
strsplit(s, " и ", fixed = T)
strsplit(s, "[[:punct:]]")
grep("труд", s)
gsub("\\b[[:alpha:]][4,5]\\b", "####", s)
gsub("\\b[[:alpha:]][4,5]\\b", "####", s)
gsub("\\b[[:alpha:]]{4,5}\\b", "####", s)
library("stringr", lib.loc="/Library/Frameworks/R.framework/Versions/3.5/Resources/library")
str_extract(s, "н.")
str_replace(s, "[иа]", "?")
str_extract_all(s, "н.")
tolower(month.name)
tolower(month.abb)
tolower(month.Abb)
tolower(month.abb)
length("Аэрофотосъёмка ландшафта уже выявила земли богачей и процветающих крестьян.")
lengths("Аэрофотосъёмка ландшафта уже выявила земли богачей и процветающих крестьян.")
nchar("Аэрофотосъёмка ландшафта уже выявила земли богачей и процветающих крестьян.")
nchar(NA)
getwd()
head(list.files9)
head(list.files())
list.dirs("..", recursive = F)
bind_diag <- function(m1, m2, fill) {
m3 <- matrix(fill,
nrow = nrow(m1) + nrow(m2),
ncol = ncol(m1) + ncol(m2))
m3[1:nrow(m1), 1:ncol(m1)] <- m1
m3[nrow(m1) + 1:nrow(m2), ncol(m1) + 1:ncol(m2)] <- m2
m3
}
m1 <- matrix(1:12, nrow = 3)
m1
library(vcd)
library(ggplot2)
titanic <- read.csv("https://stepic.org/media/attachments/course/524/train.csv")
titanic <- na.omit(titanic)
titanic <- mutate(titanic,
Survived = factor(Survived, labels = c("No", "Yes")),
Pclass = factor(Pclass, labels = c("First", "Second", "Third")),
Sex = factor(Sex, labels = c("Female", "Male")))
simple_fit <- glm(Survived ~ 1, titanic, family = "binomial")
summary(sample_fit)
summary(sample_fit)
coef(simple_fit)
table(titanic$Survived)
summary(simple_fit)
#модели с двумя номинативными предикторами
fit2 <- glm(Survived ~ Sex * Pclass, titanic, family = "binomial")
summary(fit2)
coef(fit2)
chance_from_log(coef(fit2))
coef(fit2)
summary(fit2)
df <- data.frame(swiss)
fit <- lm(Fertility ~ Examination + Catholic, swiss)
summary(fit)
summary(lm(wt ~ mpg + disp + hp, df))
#домашнее задание 2
df <- mtcars[,c(6, 1, 3, 5, 4)]
summary(lm(wt ~ mpg + disp + hp, df))
View(mtcars)
summary(lm(mpg ~ wt + as.factor(gear) + hp, df))
summary(lm(mpg ~ wt + hp, df))
ggplot(swiss, aes(x = Examination, y = Fertility)) +
geom_point()+
geom_smooth(method = 'lm')
habits <- read_sheet(goals_table, "Habits")
write_habits_result(goals_table, calculate_streaks(habits))
install.packages("swirl")
library(swirl)
swirl()
A <- matrix(0, nrow=4, ncol=5)
A
A <- matrix(1, nrow=3, ncol=4)
B <- matrx(1, nrow=3, ncol=6)
B <- matrix(1, nrow=3, ncol=6)
A
b
B
A * B
T(A)
t(A)
t(A) * B
t(A)
t(A) * B
t(A) %*% B
A %*% B
A <- c(2, 4, 6)
B <- c(3, 0, 0)
A %*% B
A <- matrix(c(2, 4, 6, 10, 12, 14, 18, 20, 22, 8, 16, 24), ncol = 3, nrow = 4)
A
A <- matrix(c(2, 4, 6, 10, 12, 14, 18, 20, 22, 8, 16, 24), ncol = 3, nrow = 4, byrow = T)
A
A %*% B
B <- matrix(c(3, 0, 0, 0, 3, 0, 0, 0, 3), ncol=3, byrow = T)
B
A %*% B
setwd("~/Downloads/Work/Personal/Programming/R/Projects/GoalsApp")
# Ver 1
# подумать о механике, как считать часы и делать предсказания на основе линейной регрессии
require(lubridate)
suppressMessages(require(dplyr))
require(formattable)
require(togglr)
require(googlesheets)
# START MODULE BUDGET & BILLS
### Include export from Toggl ###
read_toggle <- function(period){
set_toggl_api_token("1ade723dc3b40ea9aeafc0c30758d199")
cost <- 750
data <- get_time_entries(since = period[[1]], until = period[[2]])
data <- data[c(1, 4, 5, 6, 11, 15)]
names(data) <- c('Date', 'Duration', 'Project', 'Description', 'Billable', 'Tag')
data$Billable <- ifelse(data$Project == "Работа", 'TRUE', 'FALSE')
data$Date <- as.Date(data$Date)
data$Time <- hms::hms(data$Duration)
data$Duration <- seconds_to_period(data$Duration)
data$Amount <- currency(ifelse(data$Billable == 'TRUE',
hour(data$Duration) * cost +
minute(data$Duration)/60 * cost +
second(data$Duration)/60/60 * cost,
0), 'RUB ')
data <- na.exclude(data)
return(data)
}
back_to_week <- function(which_week=1, weeks=1){
d1 <- which_week * lubridate::days(7)
d2 <- weeks * lubridate::days(7)
from <- Sys.time() - d1
to <- from + d2
return(c(start=from, end=to))
}
how_much <- function(data){
data %>%
group_by(Date, Description) %>%
summarise(Price = round(sum(Amount)), Hours = sum(Time)) %>%
ungroup() %>%
select(Description, Price, Hours) %>%
filter(Price > 0) %>%
janitor::adorn_totals()
}
# module works in Bills and budget.Rmd
# END MODULE BUDGET & BILLS
# START BASE MODULE GOOGLE SHEETS
goals_table <- gs_title("Цели 2019 2.0") # this is first required step -- registering table
names_of_sheets <- gs_ws_ls(goals_table)
read_sheet <- function(reg_table, name){
size <- goals_table$ws[goals_table$ws$ws_title == name, c(4:5)]
table <- reg_table %>% gs_read(ws = name, range = cell_rows(1:size[[1]]))
table
}
# END BASE MODULE GOOGLE SHEETS
# START MODULE HABITS STREAK
calculate_streaks <- function(data){
data <- data[-c(1:7)]
col_limit <- which(as.Date(names(data), tryFormats = "%d/%m/%Y") == (Sys.Date()-1))
for_streaks <- data[1:col_limit]
streaks <- lapply(1:nrow(for_streaks), function(row_x) rbind(rle(for_streaks[row_x, ])$values,
rle(for_streaks[row_x, ])$lengths))
result <- sapply(streaks, function(x)
if (rev(x)[1,1] == 0) {
current = 0
max_st = max(x[2, which(x[1,] == 1)])
strength = current/66
data =c(current, max_st, strength)
} else {
current = rev(x)[2,1]
max_st = max(x[2, which(x[1,] == 1)])
strength = current/66
data = c(current, max_st, strength)
})
rownames(result) <- c("Streak", "Max streak", "Result")
result <- as.data.frame(t(result))
result[[3]] <- formattable::percent(result[[3]])
result <- tidyr::unnest(result)
result <- result[c(2, 3, 1)]
result
}
write_habits_result <- function(reg_table, result){
anchors <- c("C2", "D2", "E2")
for (i in 1:length(anchors)){
reg_table %>% gs_edit_cells(ws = "Habits", anchor = anchors[[i]], input = result[[i]])
Sys.sleep(0.3)
}
cat('Table was updated!')
}
# END MODULE HABITS STREAK
# START MODULE ACTUAL ESTIMATE
calculate_actual_time <- function(tasks, time) {
time <- time %>%
group_by(Description) %>%
summarise(time = sum(Time))
work_table <- left_join(tasks, time, by = c("Full name" = "Description"))
work_table$time <- ifelse(is.na(work_table$time), 0, work_table$time)
work_table$Actual <- ifelse(is.na(work_table$Actual), 0, work_table$Actual)
work_table$Actual <- ifelse(work_table$time > work_table$Actual, work_table$time, work_table$Actual)
work_table$Actual <- hms::hms(work_table$Actual)
return(work_table[['Actual']])
work_table
}
write_tasks_time <- function(reg_table, result){
reg_table %>% gs_edit_cells(ws = "Tasks", anchor = "K2", input = result)
cat('Table was updated!')
}
# END MODULE ACTUAL ESTIMATE
# # START MODULE SPRINTS
# sprints <- read_sheet(goals_table, 'Sprint')
# tasks <- read_sheet(goals_table, "Tasks")
#
# add_total_work_time <- function(sleep=9, sprint_data){
#   sprint_data$`Total work time` <-  hms::hms(period_to_seconds(days(dmy(sprint_data$`End Date`) - dmy(sprint_data$`Start Date`))) -
#                                                period_to_seconds(days(dmy(sprint_data$`End Date`) - dmy(sprint_data$`Start Date`)))*sleep/24)
#   sprint_data
# }
# s <- add_total_work_time(sprint_data = sprints)
#
# t <- tasks
# t$Estimate <- ifelse(is.na(t$Estimate), "00:00:00", t$Estimate)
# t$Estimate <- hms::hms(period_to_seconds(hms(t$Estimate)))
# t$Actual[12] <- hms::hms(0)
# t_es <- t %>%
#   group_by(Sprint) %>%
#   filter(!is.na(Sprint)) %>%
#   summarise(Estimate = sum(Estimate),
#             Actual = sum(Actual),
#             Tasks = n())
#
# # mutate will be better
# s <- left_join(s, t_es, by = c('Sprint ID' = 'Sprint'))
# Estimate time
# Сумма оцениваемого времени по всем задачам спринта
# Actual Time
# Сколькоо времени потратил по факту
# Tasks start
# Сколько было задач в спринте в начале
# Tasks end
# Сколько было задач в спринте по завершении
# Tasks wasted
# Сколько задач перенесено на след.спринт
# Efficiency
# Время в развитии и работе относительно нецелевого (процент)
# Time of working
# Сколько часов проработал (категория)
# Time of learning
# Сколько часов проучился (категория)
# Time of practicing
# Сколько часов попрактиковался (категория)
# Time wasted
# Чистое нецелевое время
# Completion
# Завершён ли спринт
# END MODULE SPRINTS
# RUN GOALS START
# Habits start
habits <- read_sheet(goals_table, "Habits")
write_habits_result(goals_table, calculate_streaks(habits))
# Habits end
# Actual estimate start
tasks <- read_sheet(goals_table, "Tasks")
time <- read_toggle(back_to_week(10, 10))
write_tasks_time(goals_table, calculate_actual_time(tasks, time))
# Actal estimate end
# RUN GOALS END
#
# predictions (unsuccesful)
# forlm <- tasks %>% filter(Status == "Done")
# model <- lm(data = forlm, period_to_seconds(hms(Estimate)) ~ period_to_seconds(hms(forlm$Actual))+`Task priority`)
#
# summary(model)
#
# tasks$prediction_Estimate <- predict(model, newdata = tasks)
#
#
# period_to_seconds(hms(forlm$Actual))
#cronR::cron_add(cronR::cron_rscript('GoalsApp.R'), frequency = 'daily', at = '17:30')
# Ver 1
# подумать о механике, как считать часы и делать предсказания на основе линейной регрессии
require(lubridate)
suppressMessages(require(dplyr))
require(formattable)
require(togglr)
require(googlesheets)
# START MODULE BUDGET & BILLS
### Include export from Toggl ###
read_toggle <- function(period){
set_toggl_api_token("1ade723dc3b40ea9aeafc0c30758d199")
cost <- 750
data <- get_time_entries(since = period[[1]], until = period[[2]])
data <- data[c(1, 4, 5, 6, 11, 15)]
names(data) <- c('Date', 'Duration', 'Project', 'Description', 'Billable', 'Tag')
data$Billable <- ifelse(data$Project == "Работа", 'TRUE', 'FALSE')
data$Date <- as.Date(data$Date)
data$Time <- hms::hms(data$Duration)
data$Duration <- seconds_to_period(data$Duration)
data$Amount <- currency(ifelse(data$Billable == 'TRUE',
hour(data$Duration) * cost +
minute(data$Duration)/60 * cost +
second(data$Duration)/60/60 * cost,
0), 'RUB ')
data <- na.exclude(data)
return(data)
}
back_to_week <- function(which_week=1, weeks=1){
d1 <- which_week * lubridate::days(7)
d2 <- weeks * lubridate::days(7)
from <- Sys.time() - d1
to <- from + d2
return(c(start=from, end=to))
}
how_much <- function(data){
data %>%
group_by(Date, Description) %>%
summarise(Price = round(sum(Amount)), Hours = sum(Time)) %>%
ungroup() %>%
select(Description, Price, Hours) %>%
filter(Price > 0) %>%
janitor::adorn_totals()
}
# module works in Bills and budget.Rmd
# END MODULE BUDGET & BILLS
# START BASE MODULE GOOGLE SHEETS
goals_table <- gs_title("Цели 2019 2.0") # this is first required step -- registering table
names_of_sheets <- gs_ws_ls(goals_table)
read_sheet <- function(reg_table, name){
size <- goals_table$ws[goals_table$ws$ws_title == name, c(4:5)]
table <- reg_table %>% gs_read(ws = name, range = cell_rows(1:size[[1]]))
table
}
# END BASE MODULE GOOGLE SHEETS
# START MODULE HABITS STREAK
calculate_streaks <- function(data){
data <- data[-c(1:7)]
col_limit <- which(as.Date(names(data), tryFormats = "%d/%m/%Y") == (Sys.Date()-1))
for_streaks <- data[1:col_limit]
streaks <- lapply(1:nrow(for_streaks), function(row_x) rbind(rle(for_streaks[row_x, ])$values,
rle(for_streaks[row_x, ])$lengths))
result <- sapply(streaks, function(x)
if (rev(x)[1,1] == 0) {
current = 0
max_st = max(x[2, which(x[1,] == 1)])
strength = current/66
data =c(current, max_st, strength)
} else {
current = rev(x)[2,1]
max_st = max(x[2, which(x[1,] == 1)])
strength = current/66
data = c(current, max_st, strength)
})
rownames(result) <- c("Streak", "Max streak", "Result")
result <- as.data.frame(t(result))
result[[3]] <- formattable::percent(result[[3]])
result <- tidyr::unnest(result)
result <- result[c(2, 3, 1)]
result
}
write_habits_result <- function(reg_table, result){
anchors <- c("C2", "D2", "E2")
for (i in 1:length(anchors)){
reg_table %>% gs_edit_cells(ws = "Habits", anchor = anchors[[i]], input = result[[i]])
Sys.sleep(0.3)
}
cat('Table was updated!')
}
# END MODULE HABITS STREAK
# START MODULE ACTUAL ESTIMATE
calculate_actual_time <- function(tasks, time) {
time <- time %>%
group_by(Description) %>%
summarise(time = sum(Time))
work_table <- left_join(tasks, time, by = c("Full name" = "Description"))
work_table$time <- ifelse(is.na(work_table$time), 0, work_table$time)
work_table$Actual <- ifelse(is.na(work_table$Actual), 0, work_table$Actual)
work_table$Actual <- ifelse(work_table$time > work_table$Actual, work_table$time, work_table$Actual)
work_table$Actual <- hms::hms(work_table$Actual)
return(work_table[['Actual']])
work_table
}
write_tasks_time <- function(reg_table, result){
reg_table %>% gs_edit_cells(ws = "Tasks", anchor = "K2", input = result)
cat('Table was updated!')
}
# END MODULE ACTUAL ESTIMATE
# # START MODULE SPRINTS
# sprints <- read_sheet(goals_table, 'Sprint')
# tasks <- read_sheet(goals_table, "Tasks")
#
# add_total_work_time <- function(sleep=9, sprint_data){
#   sprint_data$`Total work time` <-  hms::hms(period_to_seconds(days(dmy(sprint_data$`End Date`) - dmy(sprint_data$`Start Date`))) -
#                                                period_to_seconds(days(dmy(sprint_data$`End Date`) - dmy(sprint_data$`Start Date`)))*sleep/24)
#   sprint_data
# }
# s <- add_total_work_time(sprint_data = sprints)
#
# t <- tasks
# t$Estimate <- ifelse(is.na(t$Estimate), "00:00:00", t$Estimate)
# t$Estimate <- hms::hms(period_to_seconds(hms(t$Estimate)))
# t$Actual[12] <- hms::hms(0)
# t_es <- t %>%
#   group_by(Sprint) %>%
#   filter(!is.na(Sprint)) %>%
#   summarise(Estimate = sum(Estimate),
#             Actual = sum(Actual),
#             Tasks = n())
#
# # mutate will be better
# s <- left_join(s, t_es, by = c('Sprint ID' = 'Sprint'))
# Estimate time
# Сумма оцениваемого времени по всем задачам спринта
# Actual Time
# Сколькоо времени потратил по факту
# Tasks start
# Сколько было задач в спринте в начале
# Tasks end
# Сколько было задач в спринте по завершении
# Tasks wasted
# Сколько задач перенесено на след.спринт
# Efficiency
# Время в развитии и работе относительно нецелевого (процент)
# Time of working
# Сколько часов проработал (категория)
# Time of learning
# Сколько часов проучился (категория)
# Time of practicing
# Сколько часов попрактиковался (категория)
# Time wasted
# Чистое нецелевое время
# Completion
# Завершён ли спринт
# END MODULE SPRINTS
# RUN GOALS START
# Habits start
habits <- read_sheet(goals_table, "Habits")
write_habits_result(goals_table, calculate_streaks(habits))
# Habits end
# Actual estimate start
tasks <- read_sheet(goals_table, "Tasks")
time <- read_toggle(back_to_week(10, 10))
write_tasks_time(goals_table, calculate_actual_time(tasks, time))
# Actal estimate end
# RUN GOALS END
#
# predictions (unsuccesful)
# forlm <- tasks %>% filter(Status == "Done")
# model <- lm(data = forlm, period_to_seconds(hms(Estimate)) ~ period_to_seconds(hms(forlm$Actual))+`Task priority`)
#
# summary(model)
#
# tasks$prediction_Estimate <- predict(model, newdata = tasks)
#
#
# period_to_seconds(hms(forlm$Actual))
#cronR::cron_add(cronR::cron_rscript('GoalsApp.R'), frequency = 'daily', at = '17:30')
